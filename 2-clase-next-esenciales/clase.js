/*
2 - clase next.js esenciales:

Vamos a crear un proyecto con next.js y ver como esta estructurado el framework, sobre el iremos trabajando.

Vamos a la p√°gina de next.js:

https://nextjs.org/

Para crear un proyecto usaremos typescript, necesitaremos tambien node.js:

https://nextjs.org/docs/getting-started

  npx create-next-app@latest --typescript

Vemos como se crea nuestro proyecto llamado esenciales. Tenemos una imagen anexa donde se ve las opciones que hemos aceptado al hacer la instalacion. OJO mas adelante recordar instalar slint y prettier. Ver tutorial.

Una vez instalado todo vemos en el packege.json para arrancar en desarrollos el proyecto:

  npm run dev

Se nos abre el proyecto en el localhost:3000:

http://localhost:3000/

Vamos a ver como es la estructura de un proyecto:
Dentro de la carpeta src es donde vive nuestro proyecto. Vemos 2 carpetas una son pages y style.
Dentro de pages tenemos el router, eso lo veremos mas adelante.

El punto de arranque de la aplicacion lo encontramos en el archivo index.tsx
Vamos a desgranar este archivo:

Vemos el componente Head, que es un componente de Next.js:

import Head from 'next/head'

<Head>
  <title>Create Next App</title>
  <meta name="description" content="Generated by create next app" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.ico" />
</Head>

Vemos que usamos estilos, como modulos de css. Lo vemos en el componente main:

import styles from '@/styles/Home.module.css'

<main className={styles.main}>

-- FAST-REFRESH. Caracteristica por default del framework: -- üî•

Una caracteristica que vemos en Next.js es que tiene Fast Refresh, lo vemos en su documentacion:

https://nextjs.org/docs/basic-features/fast-refresh

El proyecto tiene la capacidad de autogenerarse unicamente en los nodos que estan cambiando y preservar el estado del resto de los componentes para dar una mejor experiencia a los usuarios. El equipo de vercel y Next.js implementa esta caracteristica asi que no nos debemos preocupar por implementarlo nosotros.

Lo podemos comprobar si eliminamos algo de index.tsx y vemos como se refresca y se guarda preservando el estado la p√°gina.

Esto existe desde la version 9.4 de Next.js.

-- PAGES. La carpeta importante en un proyecto: --üî•

Cuando creamos un proyecto en automatico con Next.js se nos genera la carpeta:

src/pages

Pages tiene una subcarpeta que es api, esto es un endpoint. Dentro de esta carpeta pondremos todas las APIs que tenga nuestro proyecto.

Pages en realidad es un router, internamente Next.js lo que hace es configurar un router. Esto quiere decir que si creamos otra carpeta o archivo Next.js lo va a transformar en una ruta dinamica.

Vamos a ver si queremos acceder por ejemplo a esta direccion:

http://localhost:3000/about

Si la pagina no existe nos devuelve un 404, el recurso no existe.
Entonces si creamos un archivo llamado about,js about.jsx o about.tsx y dentro creamos un componente y lo exportamos veremos que al poner la ruta nos mostrara lo que hagamos en el componente.

Vemos otro ejemplo, he creado el componente contacto.tsx y vemos que funciona igual.

http://localhost:3000/contact

Asi de facil es como crear rutas b√°sicas o el enrutador en Next.js.

-- NOTA: -- üî•
A partir de la version 13 de Next.js se introduce la carpeta de app, sera el reemplazo de pages en un futuro. pages sera migrado a app. De momneto esto esta en beta.

-- RUTAS ANIDADAS: --üî•
Ahora vamos a ver como seria si queremos una ruta anidadas.

Si creamos una carpeta dentro de pages estamos creando rutas anidadas.

pages/products/
pages/products/details
pages/list/

Vemos que dentro de cada subcarpeta he creado un index.tsx. Si no nos dara un 404.

http://localhost:3000/products
http://localhost:3000/products/detail
http://localhost:3000/list

Ahora vamos a ver como hacemos para hacer una ruta dinamica: con un id: Para eso tenemos paginas con rutas dinamicas.

http://localhost:3000/post/10

Para eso nuestro archivo debe crearse de la siguiente manera:

[id].tsx

pages/post/[id].tsx tendremos la salida por la url:

http://localhost:3000/post/1
http://localhost:3000/post/2

etc.

El nombre puede ser cualquiera:

[id-post].jsx

Si creamos un archivo con esos corchetes vamos a crear rutas dinamicas, el segundo parametros es dinamico. Esos datos de la url recordar que son un string.

-- NOTA: -- üî•
El archivo _document.tsx es como si fuera nuestro archivo App.jsx que hemos visto en proyectos de React.js libreria.

-- PRE-RENDERING: -- üî•
Por default Next.js hace pre-rendering de cada p√°gina, basicamente lo que hace es static site generation (SSG) de cada una de las p√°ginas.

Todas la p√°gina que hemos creado hasta hora hacen pre-rendering.

about.tsx
contact.tsx
list/index.tsx
post/[id].tsx
products/detail/index.tsx

etc.

Existen dos maneras en Next.js de hacer pre-rendering:
- Static Generation(Recommended),
- Server-side Rendering.

https://nextjs.org/docs/basic-features/pages

La diferencia esta en que Static Generation cuando hacemos el build time se van a generar las paginas estaticas en HTML que seran colocadas en el servidor, y que cuando tengamos una peticion esta sera servida tal cual cuando un usuario lo solicite. Son servidas al usuario en una sola ocacion cuando hace la peticion.
Este tipo de paginas son usadas como por ejemplo tenemos una landing page que solo es informativa, interaccion muy poca con usando js, tambien la podemos ver con un portfolio personal.

Repito todo lo que hemos realizado ahora son static generation.

Por otro lado tenemos la segunda opcion de hacer Pre-rendering, que es Server-side Rendering, el HTML es generado tambien en el servidor pero en cada request, o peticion que hace el usuario.

Vamos a ver ejemplo de static generation.
Lo podemos ver en el siguiente enlace:

https://next-blog-wordpress.vercel.app/

Si una p√°gina usa generaci√≥n est√°tica , el HTML de la p√°gina se genera en el momento de la compilaci√≥n . Eso significa que en producci√≥n, la p√°gina HTML se genera cuando ejecuta next build. Este HTML se reutilizar√° en cada solicitud. Puede ser almacenado en cach√© por un CDN.

Vamos a verlo en el proyecto cuando hacemos el buid la informacion que nos reporta la consola.

npm run build

$ npm run build

> esenciales@0.1.0 build

Route (pages)                              Size     First Load JS
‚îå ‚óã /                                      4.59 kB        77.9 kB
‚îú   ‚îî css/457ee4102c2cdd0e.css             1.86 kB
‚îú   /_app                                  0 B            73.3 kB
‚îú ‚óã /404                                   182 B          73.4 kB
‚îú ‚óã /about                                 272 B          73.5 kB
‚îú Œª /api/hello                             0 B            73.3 kB
‚îú ‚óã /contact                               278 B          73.5 kB
‚îú ‚óã /list                                  262 B          73.5 kB
‚îú ‚óã /post/[id]                             276 B          73.5 kB
‚îú ‚óã /products                              256 B          73.5 kB
‚îî ‚óã /products/detail                       263 B          73.5 kB
+ First Load JS shared by all              74 kB
  ‚îú chunks/framework-2c79e2a64abdb08b.js   45.2 kB
  ‚îú chunks/main-0ecb9ccfcb6c9b24.js        27 kB
  ‚îú chunks/pages/_app-5fbdfbcdfb555d2f.js  296 B
  ‚îú chunks/webpack-8fa1640cc84ba8fe.js     750 B
  ‚îî css/876d048b5dab7c28.css               706 B

Œª  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
‚óã  (Static)  automatically rendered as static HTML (uses no initial props)

Como nos muestra la consola, los achivos que llevan el simbolo de landa (Œª) son paginas Server-side Rendering y la que llevan el omega (o) son Static.

El build se genera en la carpeta .next del proyecto.

Para hacer paginas con Server-side Rendering tenemos que usar los metodos:
- getInitialProps,
- getServerSideProps.

Vamos a hacer un ejemplo de una static generation, tenemos dos casos:
Static Generation with data:
Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use these functions that Next.js provides:

- Your page content depends on external data: Use getStaticProps.
- Your page paths depend on external data: Use getStaticPaths (usually in addition to getStaticProps).

- Cuando la pagina, el 'contenido' dependa de informacion externa, por ejemplo, de una API, para eso necesitamos usar el metodo getStaticProps.

- Cuando las 'rutas de la pagina, dependan de una informacion externa usamos el metodo getStaticcPaths.

Como vemos podemos hacer Static Generation obteniendo informacion desde una API.

-- EJEMPLO: --üî•
Lo vemos dentro del proyecto. Vamos a usar la API de JSONPlaceholder:

https://jsonplaceholder.typicode.com/

https://jsonplaceholder.typicode.com/users

Lo haremos en el componente dentro de pages/list/index.tsx

Nos queda asi:

// El componente List recibe por props el resultado de hacer el fetch a la API:
const List = ({users}:any) => {
  // Este console es en el Cliente:
  console.log(users);
  return (
    <>
      <h1>User list</h1>
      <ul>
        {users.map((user:any)=>{
          return (
            <li key={user.id}>{user.name}</li>
          )
        })}
      </ul>
    </>
    );
}

// Usamos el metodo para generar static side generation, ver documentacion:
export async function getStaticProps(){
  try {
    // Nos conectamos a la API:
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    const result = await response.json();
    // Este console es en el servidor:
    console.log(result);

    // Tenemos que devolver un objeto:
    return {
      props: {
        users:result
      }
    }

  } catch (error) {
    console.log(error);
    return {}
  }
}

export default List;

Haremos ahora la build del propyecto para ver la salida de los archivos por consola.
Ha salido al hacer el build algo diferente nos apararece en el componente List que ya no (o) sino (‚óè):

info  - Generating static pages (9/9)
info  - Finalizing page optimization

Route (pages)                              Size     First Load JS
‚îå ‚óã /                                      4.59 kB        77.9 kB
‚îú   ‚îî css/457ee4102c2cdd0e.css             1.86 kB
‚îú   /_app                                  0 B            73.3 kB
‚îú ‚óã /404                                   182 B          73.4 kB
‚îú ‚óã /about                                 272 B          73.5 kB
‚îú Œª /api/hello                             0 B            73.3 kB
‚îú ‚óã /contact                               278 B          73.5 kB
‚îú ‚óè /list (317 ms)                         311 B          73.6 kB
‚îú ‚óã /post/[id]                             276 B          73.5 kB
‚îú ‚óã /products                              256 B          73.5 kB
‚îî ‚óã /products/detail                       263 B          73.5 kB
+ First Load JS shared by all              74 kB
  ‚îú chunks/framework-2c79e2a64abdb08b.js   45.2 kB
  ‚îú chunks/main-0ecb9ccfcb6c9b24.js        27 kB
  ‚îú chunks/pages/_app-5fbdfbcdfb555d2f.js  296 B
  ‚îú chunks/webpack-8fa1640cc84ba8fe.js     750 B
  ‚îî css/876d048b5dab7c28.css               706 B
Œª  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
‚óã  (Static)  automatically rendered as static HTML (uses no initial props)
‚óè  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)


Ahora tenemos una pagina estatica pero con static side generation. Ya que suamos el metodo getStaticProps. Ya que viene inforamcion de una API.

Y vemos al arrancar nuestro proyecto que vemos por la consola del navegador que se nos carga el objeto de la API de JSONPlaceholder.

Ahora nos surge la pregunta ¬øcuando usar static side generation?
Lo vemos en la documentacion de Next.js:

https://nextjs.org/docs/basic-features/pages

When should I use Static Generation?
We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

You can use Static Generation for many types of pages, including:

Marketing pages
Blog posts and portfolios
E-commerce product listings
Help and documentation
You should ask yourself: "Can I pre-render this page ahead of a user's request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

In cases like this, you can do one of the following:

Use Static Generation with Client-side data fetching: You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the Data Fetching documentation.
Use Server-Side Rendering: Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.

A ver traducimos:
Dependera del tipo de p√°gina. En la documentaci√≥n recomiendan para p√°ginas:
- De marketing,
- Los post de un portfolio,
- Listar los productos de un ecommerce,
- Documentacion de ayuda.

Si el contenido no va a variar este es el camino.

-- SERVER-SIDE RENDERING:  (SSR)-- üî•
Ahora veremos el rendering dinamico en el servidor.

La p√°gina HTML es generada en cada request, o petici√≥n, en cada peticion el servidor genera el HTML y luego lo envia al cliente.

Para crear una pagina SSR debemos exportar una funcion asincrona usando el metodo getServerSideProps.

Vamos a ver en la API de JSONPlaceholder el endpoint de imagenes:

https://jsonplaceholder.typicode.com/photos

Vamos a crear una nueva carpeta dentro de pages para ver el ejemplo:

pages/photos/index.tsx

El codigo nos queda asi dentro de index.tsx:

const Photos = ({ data }: any) => {
  // Mostramos por consola del cliente:
  console.log(data)
  return (
    <>
      <h1>Photos</h1>
      {data?.map((img: any) => {
        return (
          <img src={img.url} alt={img.title} key={img.id}/>
        )
      })}
    </>
  );
}

// Creamos la funcion con el metodo para hacer la pagina SSR:
export async function getServerSideProps() {
  try {
    // Nos conectamos a la API:
    const response = await fetch('https://jsonplaceholder.typicode.com/photos');
    const data = await response.json();
    // Este console es en el servidor:
    console.log(data);
    return {
      // Retornamos un objeto:
      props: {
        data
      }
    }

  } catch (error) {
    console.log(error)
  }
}

export default Photos;

Hacemos el build y vemos la salida por consola:

info  - Generating static pages (9/9)
info  - Finalizing page optimization

Route (pages)                              Size     First Load JS
‚îå ‚óã /                                      4.59 kB        77.9 kB
‚îú   ‚îî css/457ee4102c2cdd0e.css             1.86 kB
‚îú   /_app                                  0 B            73.3 kB
‚îú ‚óã /404                                   182 B          73.4 kB
‚îú ‚óã /about                                 272 B          73.5 kB
‚îú Œª /api/hello                             0 B            73.3 kB
‚îú ‚óã /contact                               278 B          73.5 kB
‚îú ‚óè /list (305 ms)                         343 B          73.6 kB
‚îú Œª /photos                                273 B          73.5 kB
‚îú ‚óã /post/[id]                             276 B          73.5 kB
‚îú ‚óã /products                              256 B          73.5 kB
‚îî ‚óã /products/detail                       263 B          73.5 kB
+ First Load JS shared by all              74 kB
  ‚îú chunks/framework-2c79e2a64abdb08b.js   45.2 kB
  ‚îú chunks/main-0ecb9ccfcb6c9b24.js        27 kB
  ‚îú chunks/pages/_app-5fbdfbcdfb555d2f.js  296 B
  ‚îú chunks/webpack-8fa1640cc84ba8fe.js     750 B
  ‚îî css/876d048b5dab7c28.css               706 B

Œª  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
‚óã  (Static)  automatically rendered as static HTML (uses no initial props)
‚óè  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)

Como vemos el archivo /photos lleva un landa, osea es un archivo SSR.

Esto es todo por este clase...

*/
